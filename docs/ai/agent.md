# 📄 **agent.md**

---

# **AI 개발 지원 작업 규칙 (Agent)**

> 이 문서는 Codex/ChatGPT(Agent)가 **프로젝트 내부 파일을 직접 탐색·분석·수정·생성**하는 방식에 맞춘 규칙입니다.
> 이 문서는 Codex가 실제 레포지토리에 작업할 때 따라야 할 절대 기준입니다.
> - 기본 언어: 한국어
> - 불필요한 장문 설명 금지

---

## 1\. 기본 원칙

1.  사용자가 개발 요청을 하면, Agent는 요청 유형을 먼저 분류한다:

      - 신규
      - 기존 코드 분석
      - 수정
      - 업데이트
      - 삭제

2.  사용자가 소스 코드를 따로 붙여 넣지 않아도 된다.
    Agent는 **프로젝트 내부 파일을 스스로 탐색해서 관련 코드를 읽고 분석**한다.

3.  Agent는 분석을 완료하면 **먼저 “분석 끝”** 이라고만 출력한다.
    그 다음, 사용자가 해석/수정/생성 등을 요청하거나 **“진행해줘”** 라고 말한 이후에만 실제 작업을 시작한다.

4.  Agent는 **프로젝트 실제 파일을 직접 수정하거나 새로 생성**할 수 있다.
    이때, 사용자가 이해할 수 있도록:

      - 어떤 파일을 변경/생성했는지
      - 어떤 부분이 어떻게 바뀌었는지
        를 **요약 + 필요한 코드 스니펫/전체 코드**로 설명한다.

5.  사용자가 “진행해줘” 또는 이에 준하는 승인(예: “수정해줘”, “적용해줘”)을 하기 전에는:

      - 파일 수정
      - 파일 생성
      - 삭제
        모두 **절대 금지**.

-----

## 2\. 프로젝트 내 파일 탐색 규칙

1.  Agent는 요청을 받으면 프로젝트 루트 기준으로 다음을 수행한다:

      - 관련 파일 탐색
      - 연관된 모듈/서비스/컴포넌트 추적
      - 필요한 경우 여러 파일을 연쇄적으로 읽어 맥락 이해

2.  파일을 찾을 때 기준:

      - 파일명/디렉토리 구조
      - import/export 관계
      - 도메인 네임(예: acc, ledger, common 등)
      - 테스트 파일(예: `*.spec.ts`)과 구현 파일 관계

3.  분석 과정:

      - 관련 파일(1개 이상)을 읽고 내부 구조/의존성을 파악
      - 필요 시 호출 체인/데이터 흐름까지 추적
      - 분석이 끝나면 **“분석 끝”** 만 출력하고, 그 다음 지시를 기다린다.

-----

## 3\. 작업 진행 방식 (파일 직접 수정 기준)

1.  모든 작업은 **단계별**로 진행한다.

2.  신규/수정/업데이트 작업 시 Agent는:

      - **프로젝트 실제 파일을 직접 수정/생성**한다.
      - 동시에, 사용자에게는 변경 사항을 이해할 수 있도록:
          - “어떤 파일을 수정했는지”
          - “어떤 코드 블록이 어떻게 바뀌었는지”
            를 요약하고, 필요한 경우 코드 블록으로 보여준다.
      - **의미 있는 작업 단위 완료 시** (예: 하나의 함수/API 구현 완료) 11-2 규칙에 따라 **커밋/푸시 절차를 안내**한다.

3.  파일을 수정할 때 원칙:

      - 함수/클래스/컴포넌트 단위로 **전체 맥락을 유지한 채 수정**한다.
      - 중요한 구조를 건드릴 경우, 변경 전/후를 설명한다.

4.  신규 작성된 코드에는 가능하면 `// 신규 작성` 주석을 사용해 표시한다.
    (단, 실제 코드에 주석이 불필요하다면 설명 메시지에서만 언급해도 된다.)

5.  기존 코드 일부 수정 시:

      - 의미 있는 변경 구간에는 `// 수정 영역:` 주석을 선택적으로 사용할 수 있다.
      - 또는, 응답 메시지에서 “여기 이 부분을 이렇게 바꿨다”는 식으로 diff 스타일 설명을 제공한다.

-----

## 4\. 코드 스타일 및 주석

1.  불필요한 주석은 쓰지 않는다.
2.  코드 자체로 이해 가능한 부분에는 설명 주석을 붙이지 않는다.
3.  예외 처리와 핵심 비즈니스 로직은 **주석 없이도 이해 가능하게** 작성한다.
4.  “이 코드는 반복입니다” 같은 메타 설명 주석은 금지.
5.  스타일/포맷은 프로젝트의 ESLint/Prettier 설정을 따르며, **`common-rules.md`, `backend-rules.md`, `frontend-rules.md`에 명시된 프로젝트별 규칙을 최우선으로 준수한다.**

-----

## 5\. 오류 및 문제 처리

1.  오류/버그를 수정할 때 Agent는:

      - **실제 파일을 직접 고친다.**
      - 그 후, 어떤 문제였고 어느 파일의 어느 부분을 어떻게 수정했는지 간단히 설명한다.
      - 필요 시 수정된 함수/클래스 전체를 코드 블록으로 보여준다.

2.  동일 문제가 다시 발생하지 않도록 원인을 고려해 수정한다.

3.  기존 구현 방식이 합리적이면, 불필요한 리팩터링 없이 **최소 수정**만 수행한다.

-----

## 6\. 요청 유형별 행동 지침

### ✔ 신규 개발

  - 요구사항 분석 → 관련 디렉토리/파일 구조 설계
  - 필요한 파일/모듈/경로를 결정
  - **11-1 규칙에 따라 브랜치 확인/생성 안내 후** 사용자 “진행해줘” 이후:
      - 새 파일 생성 또는 기존 파일에 신규 코드 추가
      - 생성/추가한 코드에 대해 어느 파일에 무엇을 넣었는지 설명
      - **작업 단위별로 커밋/푸시 절차 안내 (11-2)**

### ✔ 기존 코드 분석

  - Agent가 프로젝트 내 관련 파일을 찾아 읽고 전체 구조/흐름을 파악
  - 분석이 끝나면 우선 **“분석 끝”** 출력
  - 이후 사용자가 “어떻게 되어있는지 설명해줘”라고 하면:
      - 구조/흐름/핵심 로직을 요약 설명

### ✔ 수정 요청

  - 파일 탐색 → 문제 지점 찾기 → 수정 방안 설계
  - **11-1 규칙에 따라 브랜치 확인/생성 안내 후** “진행해줘” 이후:
      - 실제 파일 수정
      - 변경된 파일/위치/내용을 요약 + 필요한 코드 블록 제공
      - **작업 단위별로 커밋/푸시 절차 안내 (11-2)**

### ✔ 기능 업데이트

  - 관련 파일들 파악 후 영향 범위 확인
  - 업데이트 내용 설계
  - **11-1 규칙에 따라 브랜치 확인/생성 안내 후** 승인 후, 여러 파일을 일관성 있게 수정
  - **작업 단위별로 커밋/푸시 절차 안내 (11-2)**

### ✔ 삭제 요청

  - 삭제 범위를 명확히 파악
  - **11-1 규칙에 따라 브랜치 확인/생성 안내 후** 실제 파일/코드 삭제 시:
      - 의존성/참조 관계까지 고려
      - 삭제한 위치와 이유를 설명
      - **작업 단위별로 커밋/푸시 절차 안내 (11-2)**

-----

## 7\. 코드/변경 내용 전달 방식

Agent가 실제로 파일을 수정/생성하더라도, 사용자에게는 다음 기준으로 내용을 알려야 한다:

1.  **파일 단위 요약**

    예시:

      - 수정:
          - `apps/server/src/modules/acc/acc.service.ts` – 이메일 회원가입 로직 수정
      - 생성:
          - `apps/server/src/modules/acc/dto/create-acc.dto.ts` – 계정 생성 DTO 신규 추가

2.  **중요 변경 코드 블록 제공**

      - 핵심이 되는 함수/클래스/컴포넌트는 전체를 코드 블록으로 보여줄 수 있다.
      - 사소한 변경(변수명, 메시지 텍스트 변경 등)은 요약 + 부분 코드만 보여줘도 된다.

3.  **전체 파일이 필요할 때**

      - 사용자가 “전체 코드 보여줘”라고 요청하면,
      - 해당 파일 전체를 코드 블록으로 제공할 수 있다.

-----

## 8\. 승인 전 작업 금지

  - 사용자가 **“진행해줘”, “적용해줘”, “바꿔줘”** 등 명시적인 승인 표현을 하기 전:
      - 파일 수정/생성/삭제 작업은 하지 않는다.
  - 승인 전에는:
      - 분석
      - 설계
      - 변경 계획 제안
        만 수행한다.

-----

## 9\. AI 응답 스타일

  - 한국어 우선, 짧고 명확하게.

  - 불필요한 칭찬/감탄/잡담 금지.

  - 단계별 가이드가 필요한 경우:

      - “1단계: 브랜치 생성 → 2단계: 기능 구현 → 3단계: 커밋/푸시”
        이런 식으로 짧게 나눈다.

  - 사용자가 원하지 않는 한:

      - 과한 리팩터링 제안
      - 아키텍처 변경 제안
        은 피한다.

-----

## 10\. 대화 시작 스크립트 (요청 분류)

Agent는 개발 관련 대화가 시작되면 항상 아래 질문으로 시작한다:

```text
요청 종류를 골라주세요:
신규 / 기존 코드 분석 / 수정 / 업데이트 / 삭제
```

요청 유형에 따라 추가 질문:

  - 신규: “어떤 기능을 만들까요?”
  - 분석: “어느 부분을 위주로 분석할까요? (예: 구조, 성능, 버그 의심 지점 등)”
  - 수정/업데이트: “어떤 문제가 있거나, 어떤 식으로 바꾸고 싶으신가요?”
  - 삭제: “어떤 기능/파일을 기준으로 삭제할까요?”

-----

## 11\. Git 브랜치 & 커밋 플로우 규칙

> 브랜치 전략의 기본 원칙은 `common-rules.md` 의 **브랜치 전략**을 따른다.

### 11-1. 작업 시작 전 브랜치 확인 (강제)

  - Agent는 **신규/수정/업데이트/삭제** 등 실제 수정/생성 작업이 필요한 요청을 받으면, 다음을 수행하여 **작업 브랜치를 강제**한다:

    1.  **현재 브랜치 확인 및 질문**: 사용자에게 현재 작업할 브랜치를 물어본다.
    2.  **브랜치 미지정 시 작업 거부**: 사용자가 브랜치를 지정하지 않았다면, **절대로 작업을 진행하지 않고** 적절한 브랜치명(예: `feat/acc-signup-api`)을 제안하고 **생성 명령을 안내**한다.

  - 브랜치가 없다고 가정되면, 다음 명령 예시를 안내할 수 있다:

    ```bash
    git checkout main
    git pull origin main
    git checkout -b feat/{작업-이름}
    ```

### 11-2. 작업 완료 시 커밋/푸시 안내 (빈도 증가)

Agent는 **의미 있는 파일 수정/생성 작업 단위가 완료될 때마다** (예: 하나의 함수 구현, 하나의 컴포넌트 초안 완성 등) 항상 아래 절차를 안내한다:

```bash
git status
git add {변경된 파일들}
git commit -m "type: 설명"
git push origin feat/{작업-이름}
```

커밋 메시지는 `type: 설명` 형식을 따른다.
예:

  - `feat: 이메일 회원가입 API 구현`
  - `fix: 로그인 리다이렉트 버그 수정`
  - `docs: 기능 요구사항 명세서 추가`

### 11-3. main 머지 흐름 안내

필요 시, Agent는 기본 머지 흐름도 함께 안내한다:

```bash
git checkout main
git pull origin main
git merge feat/{작업-이름}
git push origin main
```

협업 상황이라면 PR 기반 머지도 옵션으로 제안할 수 있다.

-----

## 12\. 요약

이 agent.md는 Codex/Agent가:

  - 프로젝트 내부 파일을 **직접 탐색**
  - 요청을 분석하고 **“분석 끝”** 으로 먼저 마무리
  - 사용자의 승인 이후에만 실제 파일을 **수정/생성/삭제**
  - **작업 전에 반드시 브랜치 확인/생성을 강제**
  - **의미 있는 단위별로 커밋을 유도**
  - 변경 내용을 요약 + 필요한 코드 블록 형태로 설명
  - 브랜치/커밋 플로우까지 고려

하도록 강제하는 규칙이다.

Codex는 이 문서를 항상 기준으로 삼아야 하며, 규칙 변경 시에는 반드시 agent.md를 먼저 수정해야 한다.

---